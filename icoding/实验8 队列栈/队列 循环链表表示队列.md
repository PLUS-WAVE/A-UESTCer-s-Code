## 题目：

假设以带头结点的循环链表表示队列，并且**只设一个指针指向队尾元素结点**（注意不设头指针），请完成下列任务：

1: 队列初始化，成功返回真，否则返回假： `bool init_queue(LinkQueue *LQ);`  

2: 入队列，成功返回真，否则返回假： `bool enter_queue(LinkQueue *LQ, ElemType x);`  

3: 出队列，成功返回真，且*x为出队的值，否则返回假 `bool leave_queue(LinkQueue *LQ, ElemType *x);`

相关定义如下：

```cpp
typedef struct _QueueNode {
    ElemType data;          // 数据域
    struct _QueueNode *next;      // 指针域
}LinkQueueNode, *LinkQueue;
```

## 代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include "list.h" // 请不要删除，否则检查不通过

bool init_queue(LinkQueue* LQ)
{
    *LQ = (LinkQueue)malloc(sizeof(LinkQueueNode));
    if (*LQ == NULL) {
        return false;
    }
    (*LQ)->next = *LQ;      //'->'优先级大于'*'，所以要加括号

    return true;
}

bool enter_queue(LinkQueue* LQ, ElemType x)
{
    LinkQueue New = (LinkQueue)malloc(sizeof(LinkQueueNode));
    if (New == NULL) {
        return false;
    }
    New->data = x;
    New->next = (*LQ)->next;
    (*LQ)->next = New;
    *LQ = New;
    return true;
}

bool leave_queue(LinkQueue* LQ, ElemType* x)
{
    if (*LQ == NULL) {
        return false;
    }
    if (*LQ == (*LQ)->next) {
        return false;
    }
    LinkQueue p = (*LQ)->next->next;
    *x = p->data;
    (*LQ)->next->next = p->next;
    if (*LQ == p) {
        *LQ = (*LQ)->next;
    }
    free(p);
    return true;
}
```


