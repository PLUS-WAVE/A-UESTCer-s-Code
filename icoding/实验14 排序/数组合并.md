> æ’åºå•å…ƒå‰é¢å››é“é¢˜éƒ½æ˜¯å †ï¼Œæš—ç¤ºè¿˜ä¸å¤Ÿæ˜æ˜¾å—ğŸ‘€
> 
> ä»£ç å‰é¢é™¤äº† heap_insert_valueï¼ˆå †å…ƒç´ æ’å…¥å‡½æ•°ï¼‰éƒ½æ˜¯æŠŠå‰é¢å››é“é¢˜æ‰€ç¼–å†™çš„å‡½æ•°å¤åˆ¶è¿‡æ¥ç›´æ¥ç”¨çš„
> 
> å¯¹äº heap_insert_value å‡½æ•°ï¼Œéœ€è¦æ”¹é€ ä¸€ä¸‹ï¼Œä½¿å…¶ä¹Ÿèƒ½æ’å…¥çš„ä¿¡æ¯å®Œæ•´å¤šäº†otherInfoï¼ˆæ€ªä¸å¾— MinHeapNode é‡Œä¼šå¤šäº† otherinfo åŸæ¥éƒ½æ˜¯æœ‰ç”¨çš„å¤ªè´´å¿ƒäº†ğŸ˜­ï¼‰ï¼Œç”¨ otherinfo é‡Œçš„ i å’Œ j æ¥åˆ†åˆ«è¡¨ç¤ºã€å…ƒç´ æ‰€åœ¨æ•°ç»„çš„ç´¢å¼•ã€‘å’Œã€å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ã€‘
> 
> æ€è·¯ï¼š
> 
> å…ˆå°†æ¯ä¸ªæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…¥å †ï¼›è¾“å‡ºæœ€å°å…ƒç´ çš„åï¼Œå°†å…¶å¯¹åº”çš„æ•°ç»„ä¸­çš„ä¸‹ä¸€ ä¸ªå…ƒç´ å…¥å †ï¼Œé‡å¤å³å¯ã€‚

## é¢˜ç›®ï¼š

å‡è®¾æœ‰ n ä¸ªé•¿åº¦ä¸º k çš„å·²æ’å¥½åºï¼ˆå‡åºï¼‰çš„æ•°ç»„ï¼Œè¯·è®¾è®¡æ•°æ®ç»“æ„å’Œç®—æ³•ï¼Œå°†è¿™ n ä¸ªæ•°ç»„åˆå¹¶åˆ°ä¸€ä¸ªæ•°ç»„ï¼Œä¸”å„å…ƒç´ æŒ‰å‡åºæ’åˆ—ã€‚å³å®ç°å‡½æ•°ï¼š

```c
 void merge_arrays(const int* arr, int n, int k, int* output);
```

å…¶ä¸­ arr ä¸ºæŒ‰è¡Œä¼˜å…ˆä¿å­˜çš„ n ä¸ªé•¿åº¦éƒ½ä¸º k çš„æ•°ç»„ï¼Œoutput ä¸ºåˆå¹¶åçš„æŒ‰å‡åºæ’åˆ—çš„æ•°ç»„ï¼Œå¤§å°ä¸º nÃ—kã€‚

æ—¶é—´è¦æ±‚(è¯„åˆ†è§„åˆ™)ï¼Œå½“ n > k æ—¶ï¼š

- æ»¡åˆ†ï¼šæ—¶é—´å¤æ‚åº¦ä¸è¶…è¿‡ O(nÃ—kÃ—log(n))
- 75åˆ†ï¼šæ—¶é—´å¤æ‚åº¦ä¸è¶…è¿‡ O(nÃ—kÃ—log(n)Ã—k)
- 59åˆ†ï¼šå…¶å®ƒï¼Œå¦‚ï¼šæ—¶é—´å¤æ‚åº¦ä¸º O(n2Ã—k2) æ—¶ã€‚

## ä»£ç ï¼š

```cpp
#include<stdio.h>
#include<stdlib.h>

//---æœ¬ç¨‹åºä¸æä¾›ä»»ä½•è¾…åŠ©å‡½æ•°ï¼Œè‹¥éœ€è¦è¯·åœ¨ä¸‹æ–¹æ·»åŠ 
typedef struct _otherInfo
{
    int i;
    int j;
}OtherInfo;

typedef struct _minHeapNode
{
    int value;
    OtherInfo otherInfo;
}MinHeapNode, * PMinHeapNode;

typedef struct _minPQ {
    PMinHeapNode heap_array; // æŒ‡å‘å †å…ƒç´ æ•°ç»„
    int heap_size; // å½“å‰å †ä¸­çš„å…ƒç´ ä¸ªæ•°
    int capacity;  //å †æ•°ç»„çš„å¤§å°
}MinHeap, * PMinHeap;

// è¿”å›å †å…ƒç´ æ•°ç»„ä¸‹æ ‡ä¸º i çš„ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ä¸‹æ ‡
int parent(int i) {
    i++;// æ³¨æ„æ˜¯æ•°ç»„ä¸‹æ ‡ +1æ‰æ˜¯å®Œå…¨äºŒå‰æ ‘çš„é¡ºåºç¼–å·
    return i / 2 - 1;// æ³¨æ„è¿”å›ä¹Ÿæ˜¯æ•°ç»„ä¸‹æ ‡ æ‰€ä»¥è¦-1    
}

// è¿”å›å †å…ƒç´ æ•°ç»„ä¸‹æ ‡ä¸º i çš„ç»“ç‚¹çš„å·¦å­ç»“ç‚¹ä¸‹æ ‡
int left(int i) {
    i++;
    return i * 2 - 1;

}

// è¿”å›å †å…ƒç´ æ•°ç»„ä¸‹æ ‡ä¸º i çš„ç»“ç‚¹çš„å³å­ç»“ç‚¹ä¸‹æ ‡
int right(int i) {
    i++;
    return i * 2 + 1 - 1;
}

// äº¤æ¢ä¸¤ä¸ªå †å…ƒç´ çš„å€¼
void swap_node(MinHeapNode* x, MinHeapNode* y) {
    MinHeapNode temp = *x; // é€šè¿‡è§£å¼•ç”¨è·å–æŒ‡é’ˆæŒ‡å‘çš„å®é™…æ•°æ®
    *x = *y; // å°†æŒ‡é’ˆyæŒ‡å‘çš„æ•°æ®èµ‹å€¼ç»™æŒ‡é’ˆxæŒ‡å‘çš„ä½ç½®
    *y = temp; // å°†ä¿å­˜åœ¨tempä¸­çš„æ•°æ®èµ‹å€¼ç»™æŒ‡é’ˆyæŒ‡å‘çš„ä½ç½®
}

// å †åˆå§‹åŒ–
void init_min_heap(PMinHeap pq, int capacity) {
    pq->capacity = capacity;
    pq->heap_size = 0;
    pq->heap_array = (PMinHeapNode)malloc(capacity * sizeof(MinHeapNode));
}

// å †å…ƒç´ æ’å…¥
bool heap_insert_value(PMinHeap pq, int value, int k, int j) {
    if (pq->heap_size == pq->capacity) {
        // å †å·²æ»¡ï¼Œæ— æ³•æ’å…¥å…ƒç´ 
        return false;
    }

    // åˆ›å»ºæ–°çš„å †èŠ‚ç‚¹
    PMinHeapNode newNode = (PMinHeapNode)malloc(sizeof(MinHeapNode));
    if (newNode == NULL) {
        // å†…å­˜åˆ†é…å¤±è´¥
        return false;
    }

    // å°†å…ƒç´ æ’å…¥åˆ°å †çš„æœ€åä¸€ä¸ªä½ç½®
    int i = pq->heap_size;
    pq->heap_array[i].value = value;
    pq->heap_array[i].otherInfo.i = k;
    pq->heap_array[i].otherInfo.j = j;

    // æ›´æ–°å †å¤§å°
    pq->heap_size++;

    // ä»æ’å…¥ä½ç½®å¼€å§‹å‘ä¸Šè°ƒæ•´å †ï¼Œä»¥ç»´æŒæœ€å°å †çš„æ€§è´¨
    while (i != 0 && pq->heap_array[parent(i)].value > pq->heap_array[i].value) {
        swap_node(&pq->heap_array[i], &pq->heap_array[parent(i)]);
        i = parent(i);
    }

    return true;
}

// å †åŒ–
void min_heapify(PMinHeap pq, int k) {
    int smallest = k;              // å½“å‰èŠ‚ç‚¹æ ‡è®°ä¸ºæœ€å°å€¼

    while (true) {
        int l = left(k);           // å½“å‰èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ç´¢å¼•
        int r = right(k);          // å½“å‰èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ç´¢å¼•

        // æ¯”è¾ƒå·¦å­èŠ‚ç‚¹ä¸å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæ›´æ–°æœ€å°å€¼çš„ç´¢å¼•
        if (l < pq->heap_size && pq->heap_array[l].value < pq->heap_array[smallest].value) {
            smallest = l;
        }

        // æ¯”è¾ƒå³å­èŠ‚ç‚¹ä¸å½“å‰èŠ‚ç‚¹çš„å€¼ï¼Œæ›´æ–°æœ€å°å€¼çš„ç´¢å¼•
        if (r < pq->heap_size && pq->heap_array[r].value < pq->heap_array[smallest].value) {
            smallest = r;
        }

        // å¦‚æœæœ€å°å€¼ä¸æ˜¯å½“å‰èŠ‚ç‚¹ï¼Œåˆ™è¿›è¡Œäº¤æ¢ï¼Œå¹¶æ›´æ–°å½“å‰èŠ‚ç‚¹ç´¢å¼•
        if (smallest != k) {
            swap_node(&pq->heap_array[k], &pq->heap_array[smallest]);
            k = smallest;
        }
        else {
            break;    // å½“å‰èŠ‚ç‚¹å·²ç»æ˜¯æœ€å°å †ï¼Œé€€å‡ºå¾ªç¯
        }
    }
}

// æå–å †ä¸­çš„æœ€å°å…ƒç´ 
int extractMin(MinHeap* heap) {
    int minElement = heap->heap_array[0].value;
    heap->heap_array[0] = heap->heap_array[heap->heap_size - 1];
    heap->heap_size--;
    min_heapify(heap, 0);
    return minElement;
}

void merge_arrays(const int* arr, int n, int k, int* output) {
    // åˆ›å»ºæœ€å°å †
    MinHeap* Heap = (MinHeap*)malloc(sizeof(MinHeap));   
    init_min_heap(Heap, n);

    // å°†æ¯ä¸ªæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ’å…¥å †ä¸­
    for (int i = 0; i < n; i++) {
        // æ”¹é€ äº†ä¸€ä¸‹insertå‡½æ•°ï¼Œä½¿å…¶ä¹Ÿèƒ½æ’å…¥çš„ä¿¡æ¯å®Œæ•´ï¼ˆå¤šäº†otherInfoï¼‰
        heap_insert_value(Heap, arr[i * k], i, 0);
        // Heap->heap_array[i].otherInfo.i â€”â€”â€”â€”æ‰€åœ¨æ•°ç»„çš„ç´¢å¼•
        // Heap->heap_array[i].otherInfo.j â€”â€”â€”â€”å…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
    }

    // ä¾æ¬¡ä»å †ä¸­å–å‡ºæœ€å°å…ƒç´ ï¼Œå¹¶å°†ä¸‹ä¸€ä¸ªå…ƒç´ æ’å…¥å †ä¸­
    for (int i = 0; i < n * k; i++) {
        // è·å–æœ€å°å…ƒç´ æ‰€åœ¨æ•°ç»„çš„ç´¢å¼•å’Œå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•
        int arrIndex = Heap->heap_array[0].otherInfo.i;
        int elemIndex = Heap->heap_array[0].otherInfo.j;

        // å–å‡ºå †ä¸­çš„æœ€å°å…ƒç´ 
        output[i] = extractMin(Heap);

        // å¦‚æœå½“å‰æ•°ç»„è¿˜æœ‰å…ƒç´ ï¼Œå°†ä¸‹ä¸€ä¸ªå…ƒç´ æ’å…¥å †ä¸­
        if (elemIndex < k - 1) {
            int value = arr[arrIndex * k + elemIndex + 1];
            heap_insert_value(Heap, value, arrIndex, elemIndex + 1);
        }
    }

    // è®°å¾—ç”¨å®Œå †éœ€è¦free
    free(Heap->heap_array);
    free(Heap);
}
```
